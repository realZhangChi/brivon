[{"categories":["技术分享"],"content":"微软最近发布了 .NET 10 的首个预览版，这是一个重要的长期支持（LTS）版本。本文将为大家详细介绍 .NET 10 中的主要新特性和改进。 ","date":"2024-03-18","objectID":"/posts/dotnet10-new-features/:0:0","tags":["dotnet","技术","编程"],"title":".NET 10 预览版新特性全面解析","uri":"/posts/dotnet10-new-features/"},{"categories":["技术分享"],"content":"运行时改进 数组接口方法去虚拟化：优化了数组操作的性能 值类型数组的栈分配：提升了内存使用效率 AVX10.2 支持：增强了向量运算能力 ","date":"2024-03-18","objectID":"/posts/dotnet10-new-features/:1:0","tags":["dotnet","技术","编程"],"title":".NET 10 预览版新特性全面解析","uri":"/posts/dotnet10-new-features/"},{"categories":["技术分享"],"content":"核心库更新 证书指纹支持：现在支持除 SHA-1 外的其他指纹算法 PEM 编码数据处理：增强了对 ASCII/UTF-8 中 PEM 编码数据的处理能力 ISOWeek 新方法：为 DateOnly 类型添加了新的 ISOWeek 方法重载 字符串规范化 API：新增了处理字符 Span 的字符串规范化 API 字符串比较增强：添加了数字排序的字符串比较功能 TimeSpan 改进：新增了 FromMilliseconds 的单参数重载 ZipArchive 性能提升：显著提升了压缩性能和内存使用效率 OrderedDictionary 增强：为 OrderedDictionary\u003cTKey, TValue\u003e 添加了新的 TryAdd 和 TryGetValue 重载 矩阵变换方法：增加了更多左手矩阵变换方法 ","date":"2024-03-18","objectID":"/posts/dotnet10-new-features/:2:0","tags":["dotnet","技术","编程"],"title":".NET 10 预览版新特性全面解析","uri":"/posts/dotnet10-new-features/"},{"categories":["技术分享"],"content":"C# 14 语言特性 泛型中的 nameof：在未绑定泛型中支持 nameof 操作符 隐式 span 转换：简化了 Span 类型的使用 字段支持的属性：简化了属性的定义和访问 简单 lambda 参数的修饰符：增强了 lambda 表达式的灵活性 实验性功能：数据段中的字符串字面量 ","date":"2024-03-18","objectID":"/posts/dotnet10-new-features/:3:0","tags":["dotnet","技术","编程"],"title":".NET 10 预览版新特性全面解析","uri":"/posts/dotnet10-new-features/"},{"categories":["技术分享"],"content":"Entity Framework Core 改进 LeftJoin 支持：新增了 LINQ 的 LeftJoin 操作符支持 ExecuteUpdateAsync 增强：现在支持普通的非表达式 lambda ","date":"2024-03-18","objectID":"/posts/dotnet10-new-features/:4:0","tags":["dotnet","技术","编程"],"title":".NET 10 预览版新特性全面解析","uri":"/posts/dotnet10-new-features/"},{"categories":["技术分享"],"content":"ASP.NET Core 更新 OpenAPI 3.1 支持：内置支持 OpenAPI 3.1，并将其设为生成 OpenAPI 文档的默认版本 Blazor 优化：JavaScript 实现作为静态 Web 资源发布，大小减少 76% ","date":"2024-03-18","objectID":"/posts/dotnet10-new-features/:5:0","tags":["dotnet","技术","编程"],"title":".NET 10 预览版新特性全面解析","uri":"/posts/dotnet10-new-features/"},{"categories":["技术分享"],"content":"容器支持 Ubuntu 24.04 支持：10.0-preview 标签现使用 Ubuntu 24.04 Debian 支持：Debian 镜像使用 Debian 13 “Trixie” Ubuntu Chiseled 改进：现包含 Chisel 清单 ","date":"2024-03-18","objectID":"/posts/dotnet10-new-features/:6:0","tags":["dotnet","技术","编程"],"title":".NET 10 预览版新特性全面解析","uri":"/posts/dotnet10-new-features/"},{"categories":["技术分享"],"content":"总结 .NET 10 预览版展示了微软在性能优化、开发体验和跨平台支持方面的持续投入。作为一个 LTS 版本，它将为开发者带来更多稳定性和新功能。随着后续预览版的发布，我们期待看到更多令人兴奋的特性加入。 ","date":"2024-03-18","objectID":"/posts/dotnet10-new-features/:7:0","tags":["dotnet","技术","编程"],"title":".NET 10 预览版新特性全面解析","uri":"/posts/dotnet10-new-features/"},{"categories":["技术分享"],"content":"如何开始使用 要开始使用 .NET 10 预览版，您需要： 下载并安装 .NET 10 SDK 如果使用 Visual Studio，建议安装最新的 Visual Studio 2022 预览版 或者使用 Visual Studio Code 配合 C# Dev Kit 扩展 请注意，这是预览版本，不建议在生产环境中使用。建议在开发和测试环境中尝试新特性，并向微软提供反馈。 ","date":"2024-03-18","objectID":"/posts/dotnet10-new-features/:8:0","tags":["dotnet","技术","编程"],"title":".NET 10 预览版新特性全面解析","uri":"/posts/dotnet10-new-features/"},{"categories":["技术深度探讨"],"content":"在构建大型Blazor WebAssembly应用时，性能优化往往成为开发团队面临的最大挑战之一。本文将从实际项目经验出发，深入探讨Blazor WebAssembly的性能优化策略。 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:0:0","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"初始加载优化 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:1:0","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"1. 程序集裁剪（Assembly Trimming） 在发布配置中启用裁剪可以显著减少应用程序的大小： \u003cPropertyGroup\u003e \u003cPublishTrimmed\u003etrue\u003c/PublishTrimmed\u003e \u003cTrimMode\u003elink\u003c/TrimMode\u003e \u003c/PropertyGroup\u003e 注意事项： 需要在项目中标记动态使用的类型 使用[DynamicallyAccessedMembers]特性保留反射用到的成员 仔细测试以确保功能完整性 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:1:1","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"2. 延迟加载策略 实现路由级别的延迟加载： @page \"/counter\" @using Microsoft.AspNetCore.Components.Web \u003cPageTitle\u003eCounter\u003c/PageTitle\u003e @if (_componentLoaded) { \u003cDynamicComponent Type=\"@_counterType\" /\u003e } @code { private bool _componentLoaded; private Type _counterType; protected override async Task OnInitializedAsync() { _counterType = await Task.Run(() =\u003e typeof(Counter)); _componentLoaded = true; } } ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:1:2","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"运行时性能优化 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:2:0","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"1. 状态管理优化 避免不必要的渲染： public class StateContainer { private string _savedName; public string SavedName { get =\u003e _savedName; set { if (_savedName == value) return; _savedName = value; NotifyStateChanged(); } } public event Action OnChange; private void NotifyStateChanged() =\u003e OnChange?.Invoke(); } ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:2:1","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"2. 虚拟化长列表 使用Virtualize组件处理大数据集： \u003cdiv style=\"height: 500px; overflow-y: scroll\"\u003e \u003cVirtualize Items=\"@largeDataSet\" Context=\"item\"\u003e \u003cItemContent\u003e \u003cdiv class=\"data-row\"\u003e \u003ch3\u003e@item.Title\u003c/h3\u003e \u003cp\u003e@item.Description\u003c/p\u003e \u003c/div\u003e \u003c/ItemContent\u003e \u003c/Virtualize\u003e \u003c/div\u003e ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:2:2","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"3. 组件参数优化 使用ShouldRender()控制重渲染： private int _lastCount; protected override bool ShouldRender() { if (_lastCount != CurrentCount) { _lastCount = CurrentCount; return true; } return false; } ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:2:3","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"网络优化 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:3:0","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"1. 压缩静态资源 在Program.cs中配置压缩： builder.Services.AddResponseCompression(options =\u003e { options.EnableForHttps = true; options.Providers.Add\u003cBrotliCompressionProvider\u003e(); options.Providers.Add\u003cGzipCompressionProvider\u003e(); }); ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:3:1","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"2. 实现有效的缓存策略 services.AddScoped\u003cICacheService, LocalStorageCacheService\u003e(); public class LocalStorageCacheService : ICacheService { private readonly ILocalStorageService _localStorage; private readonly ILogger\u003cLocalStorageCacheService\u003e _logger; public async Task\u003cT\u003e GetOrCreateAsync\u003cT\u003e(string key, Func\u003cTask\u003cT\u003e\u003e factory, TimeSpan? expiration = null) { var cached = await _localStorage.GetItemAsync\u003cCacheEntry\u003cT\u003e\u003e(key); if (cached != null \u0026\u0026 !cached.IsExpired) { return cached.Value; } var value = await factory(); await _localStorage.SetItemAsync(key, new CacheEntry\u003cT\u003e { Value = value, ExpirationTime = expiration.HasValue ? DateTime.UtcNow.Add(expiration.Value) : null }); return value; } } ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:3:2","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"开发阶段优化 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:4:0","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"1. 使用开发者工具 启用Blazor WebAssembly调试 使用Chrome DevTools的Performance面板 监控内存使用和垃圾回收 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:4:1","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"2. 性能基准测试 实现性能测试组件： public class PerformanceTestComponent : ComponentBase, IDisposable { private Stopwatch _stopwatch = new(); private string _componentName; protected override void OnInitialized() { _componentName = GetType().Name; _stopwatch.Start(); Console.WriteLine($\"{_componentName} initialization started\"); } protected override void OnAfterRender(bool firstRender) { if (firstRender) { _stopwatch.Stop(); Console.WriteLine($\"{_componentName} first render completed in {_stopwatch.ElapsedMilliseconds}ms\"); } } public void Dispose() { _stopwatch?.Stop(); } } ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:4:2","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"生产环境优化 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:5:0","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"1. 预渲染策略 在Program.cs中配置预渲染： builder.Services.AddScoped\u003cIPrerenderStateService, PrerenderStateService\u003e(); public class PrerenderStateService : IPrerenderStateService { private readonly PersistentComponentState _persistentComponentState; public PrerenderStateService(PersistentComponentState persistentComponentState) { _persistentComponentState = persistentComponentState; } public async Task PersistStateAsync\u003cT\u003e(string key, T value) { await _persistentComponentState.PersistStateAsync(key, value); } } ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:5:1","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"2. 错误边界处理 实现优雅的错误处理： \u003cErrorBoundary\u003e \u003cChildContent\u003e \u003cYourComponent /\u003e \u003c/ChildContent\u003e \u003cErrorContent Context=\"exception\"\u003e \u003cdiv class=\"error-ui\"\u003e \u003ch3\u003e出错了\u003c/h3\u003e \u003cp\u003e@exception.Message\u003c/p\u003e \u003cbutton class=\"btn btn-primary\" @onclick=\"() =\u003e Navigation.NavigateTo(Navigation.Uri, forceLoad: true)\"\u003e 重新加载 \u003c/button\u003e \u003c/div\u003e \u003c/ErrorContent\u003e \u003c/ErrorBoundary\u003e ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:5:2","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"总结 Blazor WebAssembly性能优化是一个持续的过程，需要从多个层面进行考虑： 初始加载优化 运行时性能优化 网络优化 开发阶段优化 生产环境优化 通过合理运用这些优化策略，可以显著提升Blazor WebAssembly应用的性能。记住，性能优化不是一蹴而就的工作，需要在开发过程中持续关注和改进。 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:6:0","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["技术深度探讨"],"content":"参考资源 Blazor官方文档 WebAssembly性能优化指南 .NET性能最佳实践 Microsoft Blazor性能优化建议 ","date":"2024-03-18","objectID":"/posts/blazor-wasm-optimization/:7:0","tags":["Blazor","WebAssembly","性能优化",".NET","前端开发"],"title":"Blazor WebAssembly性能优化实战指南","uri":"/posts/blazor-wasm-optimization/"},{"categories":["编程语言"],"content":"模式匹配是C#中一个强大而优雅的特性，它能让我们以更简洁、更直观的方式处理复杂的数据结构和类型检查。本文将深入探讨C#中的各种模式匹配技术，从基础概念到高级应用。 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:0:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"类型模式 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:1:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"基础类型匹配 最基本的类型模式匹配示例： public static string GetDataType(object data) { return data switch { int =\u003e \"这是一个整数\", string =\u003e \"这是一个字符串\", DateTime =\u003e \"这是一个日期\", _ =\u003e \"未知类型\" }; } ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:1:1","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"类型模式与声明 结合类型检查和变量声明： public static decimal CalculatePrice(object product) { if (product is Product { IsDiscounted: true } discountedProduct) { return discountedProduct.Price * 0.9m; } return product is Product p ? p.Price : 0m; } ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:1:2","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"属性模式 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:2:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"基本属性匹配 使用属性模式简化对象属性检查： public class Order { public decimal Total { get; set; } public bool IsVIP { get; set; } public string Status { get; set; } } public static string GetOrderPriority(Order order) =\u003e order switch { { Total: \u003e 1000, IsVIP: true } =\u003e \"最高优先级\", { Total: \u003e 1000 } =\u003e \"高优先级\", { IsVIP: true } =\u003e \"中等优先级\", _ =\u003e \"普通优先级\" }; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:2:1","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"嵌套属性模式 处理复杂对象结构： public class Address { public string Country { get; set; } public string City { get; set; } } public class Customer { public string Name { get; set; } public Address ShippingAddress { get; set; } } public static decimal CalculateShippingCost(Customer customer) =\u003e customer switch { { ShippingAddress: { Country: \"中国\", City: \"北京\" } } =\u003e 10.0m, { ShippingAddress: { Country: \"中国\" } } =\u003e 20.0m, { ShippingAddress: not null } =\u003e 50.0m, _ =\u003e throw new ArgumentException(\"无效的收货地址\") }; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:2:2","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"位置模式 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:3:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"元组模式匹配 使用位置模式处理元组： public static string AnalyzePoint(Point point) =\u003e (point.X, point.Y) switch { (0, 0) =\u003e \"原点\", (0, _) =\u003e \"Y轴上的点\", (_, 0) =\u003e \"X轴上的点\", (var x, var y) when x == y =\u003e \"对角线上的点\", _ =\u003e \"普通点\" }; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:3:1","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"解构模式 结合解构和模式匹配： public record Rectangle(double Width, double Height); public static string ClassifyRectangle(Rectangle rect) =\u003e rect switch { (0, 0) =\u003e \"点\", (var w, var h) when w == h =\u003e \"正方形\", (\u003e 0, \u003e 0) =\u003e \"矩形\", _ =\u003e \"无效图形\" }; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:3:2","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"关系模式 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:4:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"数值比较模式 使用关系运算符进行模式匹配： public static string GetTemperatureAlert(double temperature) =\u003e temperature switch { \u003c 0 =\u003e \"严寒\", \u003c= 10 =\u003e \"寒冷\", \u003c= 20 =\u003e \"凉爽\", \u003c= 30 =\u003e \"适中\", \u003c= 35 =\u003e \"温暖\", \u003e 35 =\u003e \"炎热\", _ =\u003e \"无效温度\" }; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:4:1","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"组合关系模式 复杂条件的组合： public static string GetAgeGroup(int age) =\u003e age switch { \u003c= 0 =\u003e \"无效年龄\", \u003e 0 and \u003c= 2 =\u003e \"婴儿\", \u003e 2 and \u003c= 12 =\u003e \"儿童\", \u003e 12 and \u003c= 18 =\u003e \"青少年\", \u003e 18 and \u003c= 60 =\u003e \"成年人\", \u003e 60 =\u003e \"老年人\" }; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:4:2","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"逻辑模式 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:5:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"not 模式 使用not模式进行否定匹配： public static bool IsValidInput(string input) =\u003e input is not (null or \"\" or \" \"); ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:5:1","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"and 和 or 模式 组合多个条件： public static bool IsSpecialCase(object obj) =\u003e obj is (string or int) and not null; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:5:2","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"高级应用场景 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:6:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"列表模式 C# 11中的列表模式匹配： public static string AnalyzeSequence(int[] numbers) =\u003e numbers switch { [] =\u003e \"空序列\", [1, 2, 3] =\u003e \"特定序列[1,2,3]\", [0, ..] =\u003e \"以0开头的序列\", [.., 0] =\u003e \"以0结尾的序列\", [var first, .., var last] =\u003e $\"首元素为{first}，末元素为{last}的序列\" }; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:6:1","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"递归模式 处理递归数据结构： public class BinaryTree { public int Value { get; set; } public BinaryTree Left { get; set; } public BinaryTree Right { get; set; } } public static int CountNodes(BinaryTree tree) =\u003e tree switch { null =\u003e 0, { Left: null, Right: null } =\u003e 1, { Left: var l, Right: var r } =\u003e 1 + CountNodes(l) + CountNodes(r) }; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:6:2","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"性能考虑 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:7:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"编译时类型检查 模式匹配在编译时进行类型检查，有助于避免运行时错误： public static decimal ProcessValue\u003cT\u003e(T value) =\u003e value switch { int i =\u003e i * 2, decimal d =\u003e d * 1.5m, double d =\u003e (decimal)(d * 1.5), // 编译时会检查类型覆盖情况 _ =\u003e throw new ArgumentException($\"不支持的类型: {typeof(T)}\") }; ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:7:1","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"优化建议 按照最具体到最一般的顺序排列模式 避免过度复杂的模式组合 考虑使用switch表达式而不是switch语句 利用编译器优化 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:7:2","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"最佳实践 使用模式匹配提高代码可读性 合理组合不同类型的模式 注意处理所有可能的情况 保持模式简单明了 适当使用when子句添加额外条件 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:8:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"总结 C#的模式匹配特性为我们提供了强大而灵活的工具，可以： 简化复杂的类型检查和分支逻辑 提高代码的可读性和维护性 减少代码冗余 提供编译时类型安全 通过合理使用模式匹配，我们可以写出更简洁、更优雅的代码。随着C#语言的发展，模式匹配特性还在不断增强，为我们提供更多可能性。 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:9:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["编程语言"],"content":"参考资源 C#语言规范 Microsoft文档 .NET官方博客 C#设计模式最佳实践指南 ","date":"2024-03-18","objectID":"/posts/csharp-pattern-matching/:10:0","tags":["C#",".NET","模式匹配","编程技巧"],"title":"C# 模式匹配全面指南：从基础到高级应用","uri":"/posts/csharp-pattern-matching/"},{"categories":["移动开发"],"content":"在.NET MAUI应用开发中，虽然框架提供了丰富的内置控件，但有时我们仍需要开发自定义控件来满足特定的业务需求。本文将深入探讨MAUI自定义控件的开发技术，从基础概念到实战应用。 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:0:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"基础知识 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:1:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"控件类型 MAUI中的控件主要分为以下几类： 视图控件（Views） 布局控件（Layouts） 页面控件（Pages） 单元控件（Cells） ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:1:1","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"控件继承体系 public class CustomControl : View { public CustomControl() { // 初始化代码 } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:1:2","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"自定义视图控件 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:2:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"1. 基本结构 创建一个简单的进度指示器： public class CircularProgressBar : View { public static readonly BindableProperty ProgressProperty = BindableProperty.Create( nameof(Progress), typeof(double), typeof(CircularProgressBar), 0.0, propertyChanged: OnProgressChanged); public double Progress { get =\u003e (double)GetValue(ProgressProperty); set =\u003e SetValue(ProgressProperty, value); } private static void OnProgressChanged(BindableObject bindable, object oldValue, object newValue) { var control = (CircularProgressBar)bindable; control.InvalidateLayout(); } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:2:1","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"2. 平台特定实现 Android实现 [assembly: ExportRenderer(typeof(CircularProgressBar), typeof(CircularProgressBarRenderer))] namespace YourApp.Platforms.Android { public class CircularProgressBarRenderer : ViewRenderer\u003cCircularProgressBar, Android.Views.View\u003e { public CircularProgressBarRenderer(Context context) : base(context) { } protected override void OnElementChanged(ElementChangedEventArgs\u003cCircularProgressBar\u003e e) { base.OnElementChanged(e); if (Control == null) { var nativeControl = new Android.Views.View(Context); SetNativeControl(nativeControl); } if (e.NewElement != null) { // 设置新元素的属性 UpdateProgress(); } } private void UpdateProgress() { // 更新进度显示 Invalidate(); } } } iOS实现 [assembly: ExportRenderer(typeof(CircularProgressBar), typeof(CircularProgressBarRenderer))] namespace YourApp.Platforms.iOS { public class CircularProgressBarRenderer : ViewRenderer\u003cCircularProgressBar, UIView\u003e { protected override void OnElementChanged(ElementChangedEventArgs\u003cCircularProgressBar\u003e e) { base.OnElementChanged(e); if (Control == null) { var nativeControl = new UIView(); SetNativeControl(nativeControl); } if (e.NewElement != null) { UpdateProgress(); } } private void UpdateProgress() { // 使用CoreGraphics绘制进度 SetNeedsDisplay(); } } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:2:2","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"自定义布局控件 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:3:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"1. 基本实现 创建一个流式布局控件： public class FlowLayout : Layout\u003cView\u003e { protected override ILayoutManager CreateLayoutManager() { return new FlowLayoutManager(this); } } public class FlowLayoutManager : LayoutManager { public FlowLayoutManager(ILayout layout) : base(layout) { } public override Size Measure(double widthConstraint, double heightConstraint) { var width = 0.0; var height = 0.0; var currentLineWidth = 0.0; var currentLineHeight = 0.0; foreach (var child in Layout) { var childSize = child.Measure(widthConstraint, heightConstraint); if (currentLineWidth + childSize.Width \u003e widthConstraint) { // 换行 width = Math.Max(width, currentLineWidth); height += currentLineHeight; currentLineWidth = childSize.Width; currentLineHeight = childSize.Height; } else { currentLineWidth += childSize.Width; currentLineHeight = Math.Max(currentLineHeight, childSize.Height); } } // 处理最后一行 width = Math.Max(width, currentLineWidth); height += currentLineHeight; return new Size(width, height); } public override Size ArrangeChildren(Rect bounds) { var currentX = bounds.X; var currentY = bounds.Y; var lineHeight = 0.0; foreach (var child in Layout) { var childSize = child.DesiredSize; if (currentX + childSize.Width \u003e bounds.Width) { // 换行 currentX = bounds.X; currentY += lineHeight; lineHeight = 0; } child.Arrange(new Rect(currentX, currentY, childSize.Width, childSize.Height)); currentX += childSize.Width; lineHeight = Math.Max(lineHeight, childSize.Height); } return new Size(bounds.Width, currentY + lineHeight); } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:3:1","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"自定义控件样式 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:4:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"1. 控件主题 \u003cResourceDictionary xmlns=\"http://schemas.microsoft.com/dotnet/2021/maui\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:YourApp.Controls\"\u003e \u003cStyle TargetType=\"local:CircularProgressBar\"\u003e \u003cSetter Property=\"BackgroundColor\" Value=\"Transparent\" /\u003e \u003cSetter Property=\"ProgressColor\" Value=\"{AppThemeBinding Light={StaticResource Primary}, Dark={StaticResource PrimaryDark}}\" /\u003e \u003cSetter Property=\"StrokeWidth\" Value=\"10\" /\u003e \u003c/Style\u003e \u003c/ResourceDictionary\u003e ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:4:1","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"2. 动态样式 public class CircularProgressBar : View { public static readonly BindableProperty ProgressColorProperty = BindableProperty.Create( nameof(ProgressColor), typeof(Color), typeof(CircularProgressBar), Colors.Blue); public Color ProgressColor { get =\u003e (Color)GetValue(ProgressColorProperty); set =\u003e SetValue(ProgressColorProperty, value); } protected override void OnPropertyChanged([CallerMemberName] string propertyName = null) { base.OnPropertyChanged(propertyName); if (propertyName == nameof(ProgressColor)) { InvalidateLayout(); } } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:4:2","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"高级特性 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:5:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"1. 手势识别 public class TouchableView : View { public event EventHandler\u003cTouchEventArgs\u003e TouchBegan; public event EventHandler\u003cTouchEventArgs\u003e TouchMoved; public event EventHandler\u003cTouchEventArgs\u003e TouchEnded; private readonly TapGestureRecognizer _tapGestureRecognizer; private readonly PanGestureRecognizer _panGestureRecognizer; public TouchableView() { _tapGestureRecognizer = new TapGestureRecognizer(); _tapGestureRecognizer.Tapped += OnTapped; GestureRecognizers.Add(_tapGestureRecognizer); _panGestureRecognizer = new PanGestureRecognizer(); _panGestureRecognizer.PanUpdated += OnPanUpdated; GestureRecognizers.Add(_panGestureRecognizer); } private void OnTapped(object sender, EventArgs e) { TouchBegan?.Invoke(this, new TouchEventArgs(new Point())); } private void OnPanUpdated(object sender, PanUpdatedEventArgs e) { switch (e.StatusType) { case GestureStatus.Started: TouchBegan?.Invoke(this, new TouchEventArgs(e.TotalX, e.TotalY)); break; case GestureStatus.Running: TouchMoved?.Invoke(this, new TouchEventArgs(e.TotalX, e.TotalY)); break; case GestureStatus.Completed: TouchEnded?.Invoke(this, new TouchEventArgs(e.TotalX, e.TotalY)); break; } } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:5:1","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"2. 动画支持 public class AnimatedProgressBar : ProgressBar { public static readonly BindableProperty AnimationDurationProperty = BindableProperty.Create( nameof(AnimationDuration), typeof(uint), typeof(AnimatedProgressBar), 250u); public uint AnimationDuration { get =\u003e (uint)GetValue(AnimationDurationProperty); set =\u003e SetValue(AnimationDurationProperty, value); } public async Task AnimateProgressAsync(double progress) { var animation = new Animation(v =\u003e Progress = v, Progress, progress); animation.Commit(this, \"ProgressAnimation\", 16, AnimationDuration, Easing.CubicInOut); await Task.Delay((int)AnimationDuration); } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:5:2","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"性能优化 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:6:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"1. 绘制优化 public class OptimizedCustomView : View { private SKPath _cachedPath; private double _lastWidth; private double _lastHeight; protected override void OnSizeAllocated(double width, double height) { base.OnSizeAllocated(width, height); if (Math.Abs(width - _lastWidth) \u003e 0.001 || Math.Abs(height - _lastHeight) \u003e 0.001) { _cachedPath = CreatePath(width, height); _lastWidth = width; _lastHeight = height; } } private SKPath CreatePath(double width, double height) { // 创建和缓存路径 var path = new SKPath(); // 添加绘制指令 return path; } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:6:1","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"2. 内存管理 public class ResourceEfficientControl : View, IDisposable { private bool _disposed; private SKBitmap _bitmap; protected override void OnDisposing() { if (!_disposed) { _bitmap?.Dispose(); _bitmap = null; _disposed = true; } base.OnDisposing(); } public void Dispose() { OnDisposing(); } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:6:2","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"测试 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:7:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"1. 单元测试 [TestClass] public class CustomControlTests { [TestMethod] public void TestProgressProperty() { var control = new CircularProgressBar(); control.Progress = 0.5; Assert.AreEqual(0.5, control.Progress); } [TestMethod] public void TestProgressPropertyChangeNotification() { var control = new CircularProgressBar(); var propertyChanged = false; control.PropertyChanged += (s, e) =\u003e { if (e.PropertyName == nameof(CircularProgressBar.Progress)) { propertyChanged = true; } }; control.Progress = 0.7; Assert.IsTrue(propertyChanged); } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:7:1","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"2. UI测试 [TestClass] public class CustomControlUITests { IApp app; [TestInitialize] public void BeforeEachTest() { app = ConfigureApp .Android .StartApp(); } [TestMethod] public void TestControlVisibility() { app.WaitForElement(c =\u003e c.Marked(\"customControl\")); app.Tap(c =\u003e c.Marked(\"customControl\")); app.WaitForElement(c =\u003e c.Marked(\"controlResponse\")); } } ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:7:2","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"最佳实践 控件设计原则 保持单一职责 提供合适的默认值 支持主题定制 考虑可访问性 性能注意事项 避免过度绘制 合理使用缓存 优化布局计算 及时释放资源 可维护性建议 编写完整的文档 提供使用示例 遵循命名规范 实现适当的接口 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:8:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"总结 MAUI自定义控件开发是一个复杂但有趣的过程，需要考虑： 跨平台兼容性 性能优化 用户体验 代码可维护性 通过本文介绍的技术和最佳实践，您应该能够开发出高质量的MAUI自定义控件。记住，好的控件不仅要满足功能需求，还要考虑性能、可用性和可维护性。 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:9:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["移动开发"],"content":"参考资源 MAUI官方文档 .NET MAUI控件开发指南 Microsoft开发者博客 MAUI社区讨论 ","date":"2024-03-18","objectID":"/posts/maui-custom-controls/:10:0","tags":["MAUI",".NET","跨平台开发","移动开发","自定义控件"],"title":"MAUI自定义控件开发实战指南","uri":"/posts/maui-custom-controls/"},{"categories":["桌面应用开发"],"content":"WPF MVVM模式深度解析：原理与实践 MVVM（Model-View-ViewModel）是WPF应用程序开发中最重要的设计模式之一。本文将深入探讨MVVM的核心概念、实现原理以及最佳实践，帮助您构建可维护、可测试的WPF应用程序。 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:0:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"MVVM基础架构 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:1:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"基础类实现 public abstract class ViewModelBase : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } protected bool SetProperty\u003cT\u003e(ref T field, T value, [CallerMemberName] string propertyName = null) { if (EqualityComparer\u003cT\u003e.Default.Equals(field, value)) return false; field = value; OnPropertyChanged(propertyName); return true; } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:1:1","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"命令实现 public class RelayCommand : ICommand { private readonly Action\u003cobject\u003e _execute; private readonly Func\u003cobject, bool\u003e _canExecute; public event EventHandler CanExecuteChanged { add =\u003e CommandManager.RequerySuggested += value; remove =\u003e CommandManager.RequerySuggested -= value; } public RelayCommand(Action\u003cobject\u003e execute, Func\u003cobject, bool\u003e canExecute = null) { _execute = execute ?? throw new ArgumentNullException(nameof(execute)); _canExecute = canExecute; } public bool CanExecute(object parameter) { return _canExecute == null || _canExecute(parameter); } public void Execute(object parameter) { _execute(parameter); } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:1:2","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"数据绑定 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:2:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"属性绑定 public class UserViewModel : ViewModelBase { private string _username; private string _email; private bool _isActive; public string Username { get =\u003e _username; set =\u003e SetProperty(ref _username, value); } public string Email { get =\u003e _email; set { if (SetProperty(ref _email, value)) { ValidateEmail(); } } } public bool IsActive { get =\u003e _isActive; set { if (SetProperty(ref _isActive, value)) { OnActiveStatusChanged(); } } } private void ValidateEmail() { // 邮箱验证逻辑 } private void OnActiveStatusChanged() { // 状态变更处理 } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:2:1","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"集合绑定 public class ProductsViewModel : ViewModelBase { private readonly ObservableCollection\u003cProductViewModel\u003e _products; private ProductViewModel _selectedProduct; public ProductsViewModel() { _products = new ObservableCollection\u003cProductViewModel\u003e(); LoadProducts(); } public ObservableCollection\u003cProductViewModel\u003e Products =\u003e _products; public ProductViewModel SelectedProduct { get =\u003e _selectedProduct; set { if (SetProperty(ref _selectedProduct, value)) { OnSelectedProductChanged(); } } } private async void LoadProducts() { var products = await _productService.GetProductsAsync(); foreach (var product in products) { _products.Add(new ProductViewModel(product)); } } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:2:2","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"依赖注入 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:3:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"服务注册 public class Startup { public void ConfigureServices(IServiceCollection services) { // 注册服务 services.AddSingleton\u003cIProductService, ProductService\u003e(); services.AddSingleton\u003cIUserService, UserService\u003e(); // 注册ViewModels services.AddTransient\u003cMainViewModel\u003e(); services.AddTransient\u003cProductsViewModel\u003e(); services.AddTransient\u003cUserViewModel\u003e(); } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:3:1","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"ViewModel注入 public class MainViewModel : ViewModelBase { private readonly IProductService _productService; private readonly IUserService _userService; public MainViewModel( IProductService productService, IUserService userService) { _productService = productService; _userService = userService; InitializeCommands(); } private void InitializeCommands() { SaveCommand = new RelayCommand(ExecuteSave, CanExecuteSave); RefreshCommand = new RelayCommand(ExecuteRefresh); } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:3:2","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"导航服务 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:4:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"导航实现 public interface INavigationService { void NavigateTo\u003cT\u003e() where T : ViewModelBase; void NavigateBack(); } public class NavigationService : INavigationService { private readonly IServiceProvider _serviceProvider; private readonly Stack\u003cViewModelBase\u003e _navigationStack; public event EventHandler\u003cViewModelBase\u003e CurrentViewModelChanged; public NavigationService(IServiceProvider serviceProvider) { _serviceProvider = serviceProvider; _navigationStack = new Stack\u003cViewModelBase\u003e(); } public void NavigateTo\u003cT\u003e() where T : ViewModelBase { var viewModel = _serviceProvider.GetRequiredService\u003cT\u003e(); _navigationStack.Push(viewModel); CurrentViewModelChanged?.Invoke(this, viewModel); } public void NavigateBack() { if (_navigationStack.Count \u003e 1) { _navigationStack.Pop(); var previousViewModel = _navigationStack.Peek(); CurrentViewModelChanged?.Invoke(this, previousViewModel); } } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:4:1","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"消息传递 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:5:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"消息中心 public class MessageBus { private static readonly MessageBus Instance = new(); private readonly Dictionary\u003cType, List\u003cobject\u003e\u003e _subscribers; private MessageBus() { _subscribers = new Dictionary\u003cType, List\u003cobject\u003e\u003e(); } public static MessageBus Default =\u003e Instance; public void Subscribe\u003cTMessage\u003e(Action\u003cTMessage\u003e action) { var type = typeof(TMessage); if (!_subscribers.ContainsKey(type)) { _subscribers[type] = new List\u003cobject\u003e(); } _subscribers[type].Add(action); } public void Publish\u003cTMessage\u003e(TMessage message) { var type = typeof(TMessage); if (_subscribers.ContainsKey(type)) { foreach (var subscriber in _subscribers[type].OfType\u003cAction\u003cTMessage\u003e\u003e()) { subscriber(message); } } } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:5:1","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"消息使用 public class ProductUpdatedMessage { public int ProductId { get; set; } public string ProductName { get; set; } } public class ProductViewModel : ViewModelBase { public ProductViewModel() { MessageBus.Default.Subscribe\u003cProductUpdatedMessage\u003e(OnProductUpdated); } private void OnProductUpdated(ProductUpdatedMessage message) { if (ProductId == message.ProductId) { ProductName = message.ProductName; } } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:5:2","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"验证 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:6:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"数据验证 public class UserViewModel : ViewModelBase, INotifyDataErrorInfo { private readonly Dictionary\u003cstring, List\u003cstring\u003e\u003e _errors; public event EventHandler\u003cDataErrorsChangedEventArgs\u003e ErrorsChanged; public bool HasErrors =\u003e _errors.Any(); public IEnumerable GetErrors(string propertyName) { return _errors.ContainsKey(propertyName) ? _errors[propertyName] : null; } protected void ValidateProperty(string propertyName) { var errors = new List\u003cstring\u003e(); switch (propertyName) { case nameof(Email): if (string.IsNullOrEmpty(Email)) { errors.Add(\"邮箱不能为空\"); } else if (!Regex.IsMatch(Email, @\"^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$\")) { errors.Add(\"邮箱格式不正确\"); } break; } if (errors.Any()) { _errors[propertyName] = errors; } else { _errors.Remove(propertyName); } ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName)); } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:6:1","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"单元测试 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:7:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"ViewModel测试 [TestClass] public class UserViewModelTests { private Mock\u003cIUserService\u003e _userServiceMock; private UserViewModel _viewModel; [TestInitialize] public void Setup() { _userServiceMock = new Mock\u003cIUserService\u003e(); _viewModel = new UserViewModel(_userServiceMock.Object); } [TestMethod] public void SaveCommand_WithValidData_CallsUserService() { // Arrange _viewModel.Username = \"testuser\"; _viewModel.Email = \"test@example.com\"; // Act _viewModel.SaveCommand.Execute(null); // Assert _userServiceMock.Verify(x =\u003e x.SaveUser(It.IsAny\u003cUserModel\u003e()), Times.Once); } [TestMethod] public void Email_WithInvalidFormat_HasValidationError() { // Arrange string invalidEmail = \"invalid-email\"; // Act _viewModel.Email = invalidEmail; // Assert Assert.IsTrue(_viewModel.HasErrors); var errors = _viewModel.GetErrors(nameof(_viewModel.Email)); Assert.IsNotNull(errors); } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:7:1","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"性能优化 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:8:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"绑定优化 public class LazyLoadingViewModel : ViewModelBase { private readonly Lazy\u003cExpensiveData\u003e _expensiveData; public LazyLoadingViewModel() { _expensiveData = new Lazy\u003cExpensiveData\u003e(() =\u003e { // 延迟加载昂贵的数据 return LoadExpensiveData(); }); } public ExpensiveData Data =\u003e _expensiveData.Value; } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:8:1","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"虚拟化支持 \u003cListView VirtualizingPanel.IsVirtualizing=\"True\" VirtualizingPanel.VirtualizationMode=\"Recycling\" ScrollViewer.IsDeferredScrollingEnabled=\"True\" ItemsSource=\"{Binding LargeCollection}\"\u003e \u003cListView.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cStackPanel\u003e \u003cTextBlock Text=\"{Binding Name}\" /\u003e \u003cTextBlock Text=\"{Binding Description}\" /\u003e \u003c/StackPanel\u003e \u003c/DataTemplate\u003e \u003c/ListView.ItemTemplate\u003e \u003c/ListView\u003e ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:8:2","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"最佳实践 ViewModel设计原则 保持ViewModel的独立性 避免在ViewModel中直接操作View 使用命令而不是事件 实现适当的接口 数据绑定建议 使用适当的绑定模式 注意集合更新的性能影响 合理使用虚拟化 处理大数据集时考虑分页 代码组织 遵循单一职责原则 使用依赖注入 实现适当的接口 保持代码的可测试性 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:9:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"常见问题解决 内存泄漏 public class ViewModel : ViewModelBase, IDisposable { private bool _disposed; protected virtual void Dispose(bool disposing) { if (!_disposed) { if (disposing) { // 清理托管资源 UnsubscribeFromEvents(); } _disposed = true; } } public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } } UI更新问题 public class ViewModel : ViewModelBase { private async Task UpdateUIAsync() { await Application.Current.Dispatcher.InvokeAsync(() =\u003e { // UI更新代码 UpdateUI(); }); } } ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:10:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"总结 MVVM模式是WPF应用程序开发中的核心模式，通过本文我们详细探讨了： MVVM的基础架构 数据绑定机制 依赖注入的应用 导航和消息传递 验证和测试 性能优化策略 掌握这些知识和最佳实践，将帮助您开发出更加健壮、可维护的WPF应用程序。 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:11:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["桌面应用开发"],"content":"参考资源 WPF官方文档 Microsoft MVVM指南 .NET桌面应用开发最佳实践 WPF性能优化指南 ","date":"2024-03-18","objectID":"/posts/wpf-mvvm-deep-dive/:12:0","tags":["WPF","MVVM",".NET","桌面开发","设计模式"],"title":"WPF MVVM模式深度解析：原理与实践","uri":"/posts/wpf-mvvm-deep-dive/"},{"categories":["Web开发"],"content":"Razor组件是Blazor应用程序的核心构建块，理解其生命周期对于开发高质量的Web应用至关重要。本文将深入探讨Razor组件的完整生命周期，包括各个阶段的细节和最佳实践。 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:0:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"生命周期概述 Razor组件的生命周期主要包含以下阶段： 组件初始化 参数设置 渲染 事件处理 销毁 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:1:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"初始化阶段 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:2:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"构造函数 public class MyComponent : ComponentBase { private readonly ILogger\u003cMyComponent\u003e _logger; private readonly IServiceProvider _serviceProvider; public MyComponent(ILogger\u003cMyComponent\u003e logger, IServiceProvider serviceProvider) { _logger = logger; _serviceProvider = serviceProvider; _logger.LogInformation(\"组件构造函数被调用\"); } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:2:1","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"SetParametersAsync public override async Task SetParametersAsync(ParameterView parameters) { _logger.LogInformation(\"SetParametersAsync开始执行\"); await base.SetParametersAsync(parameters); _logger.LogInformation(\"参数设置完成\"); } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:2:2","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"参数处理 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:3:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"参数验证 [Parameter] public int Count { get; set; } [Parameter] public string Title { get; set; } public override async Task SetParametersAsync(ParameterView parameters) { await base.SetParametersAsync(parameters); if (Count \u003c 0) { throw new ArgumentException(\"Count不能为负数\"); } if (string.IsNullOrEmpty(Title)) { Title = \"默认标题\"; } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:3:1","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"OnParametersSet protected override async Task OnParametersSetAsync() { await base.OnParametersSetAsync(); // 参数设置后的异步操作 await LoadDataAsync(); } protected override void OnParametersSet() { base.OnParametersSet(); // 参数设置后的同步操作 UpdateInternalState(); } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:3:2","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"渲染阶段 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:4:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"OnInitialized protected override async Task OnInitializedAsync() { await base.OnInitializedAsync(); try { await InitializeDataAsync(); _logger.LogInformation(\"组件初始化完成\"); } catch (Exception ex) { _logger.LogError(ex, \"组件初始化失败\"); throw; } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:4:1","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"OnAfterRender protected override async Task OnAfterRenderAsync(bool firstRender) { await base.OnAfterRenderAsync(firstRender); if (firstRender) { await InitializeJsInteropAsync(); _logger.LogInformation(\"首次渲染完成\"); } else { _logger.LogInformation(\"重新渲染完成\"); } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:4:2","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"状态管理 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:5:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"StateHasChanged private async Task UpdateDataAsync() { try { await _dataService.UpdateAsync(); StateHasChanged(); } catch (Exception ex) { _logger.LogError(ex, \"数据更新失败\"); } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:5:1","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"ShouldRender private string _lastTitle; protected override bool ShouldRender() { var shouldRender = Title != _lastTitle; _lastTitle = Title; return shouldRender; } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:5:2","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"事件处理 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:6:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"事件回调 [Parameter] public EventCallback\u003cstring\u003e OnValueChanged { get; set; } private async Task HandleValueChanged(string newValue) { try { await OnValueChanged.InvokeAsync(newValue); _logger.LogInformation(\"值已更改: {Value}\", newValue); } catch (Exception ex) { _logger.LogError(ex, \"处理值更改事件时出错\"); } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:6:1","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"组件通信 [CascadingParameter] private ThemeState ThemeState { get; set; } protected override void OnInitialized() { ThemeState.OnThemeChanged += async (sender, theme) =\u003e { await InvokeAsync(() =\u003e { _currentTheme = theme; StateHasChanged(); }); }; } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:6:2","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"资源管理 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:7:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"IDisposable实现 public class MyComponent : ComponentBase, IDisposable { private bool _disposed; private IDisposable _subscription; protected override void OnInitialized() { _subscription = _dataService.Subscribe(OnDataChanged); } public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if (!_disposed) { if (disposing) { _subscription?.Dispose(); _logger.LogInformation(\"组件资源已释放\"); } _disposed = true; } } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:7:1","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"IAsyncDisposable实现 public class MyComponent : ComponentBase, IAsyncDisposable { private bool _disposed; private IAsyncDisposable _asyncResource; public async ValueTask DisposeAsync() { await DisposeAsyncCore(); Dispose(false); GC.SuppressFinalize(this); } protected virtual async ValueTask DisposeAsyncCore() { if (!_disposed) { if (_asyncResource != null) { await _asyncResource.DisposeAsync(); } _disposed = true; } } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:7:2","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"性能优化 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:8:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"渲染优化 public class OptimizedComponent : ComponentBase { private RenderFragment _cachedContent; private string _lastKey; [Parameter] public string Key { get; set; } protected override void OnParametersSet() { if (_lastKey != Key) { _cachedContent = builder =\u003e { builder.OpenElement(0, \"div\"); builder.AddContent(1, GenerateContent()); builder.CloseElement(); }; _lastKey = Key; } } protected override void BuildRenderTree(RenderTreeBuilder builder) { builder.AddContent(0, _cachedContent); } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:8:1","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"内存优化 public class MemoryEfficientComponent : ComponentBase { private WeakReference\u003cobject\u003e _cachedData; private object GetCachedData() { object data; if (_cachedData != null \u0026\u0026 _cachedData.TryGetTarget(out data)) { return data; } data = LoadData(); _cachedData = new WeakReference\u003cobject\u003e(data); return data; } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:8:2","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"调试和错误处理 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:9:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"错误边界 \u003cErrorBoundary\u003e \u003cChildContent\u003e \u003cYourComponent /\u003e \u003c/ChildContent\u003e \u003cErrorContent Context=\"exception\"\u003e \u003cdiv class=\"error-ui\"\u003e \u003ch3\u003e组件发生错误\u003c/h3\u003e \u003cp\u003e@exception.Message\u003c/p\u003e @if (_isDevelopment) { \u003cpre\u003e@exception.StackTrace\u003c/pre\u003e } \u003c/div\u003e \u003c/ErrorContent\u003e \u003c/ErrorBoundary\u003e @code { [Inject] private IWebHostEnvironment Environment { get; set; } private bool _isDevelopment =\u003e Environment.IsDevelopment(); } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:9:1","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"生命周期日志 public class LoggingComponent : ComponentBase { private readonly ILogger\u003cLoggingComponent\u003e _logger; private readonly Stopwatch _renderStopwatch = new(); protected override async Task OnInitializedAsync() { _logger.LogInformation(\"组件初始化开始\"); _renderStopwatch.Start(); try { await base.OnInitializedAsync(); } finally { _renderStopwatch.Stop(); _logger.LogInformation(\"组件初始化完成，耗时: {ElapsedMs}ms\", _renderStopwatch.ElapsedMilliseconds); } } } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:9:2","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"最佳实践 生命周期方法使用建议 避免在构造函数中执行复杂逻辑 使用异步方法处理I/O操作 合理实现资源释放 注意处理组件状态 性能优化建议 适当使用ShouldRender 缓存不经常变化的内容 避免不必要的状态更新 合理使用异步操作 错误处理建议 实现错误边界 记录关键操作日志 优雅降级 提供用户反馈 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:10:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"常见问题解决 组件不更新 // 错误方式 private void UpdateState() { _state = newState; // 不会触发重新渲染 } // 正确方式 private void UpdateState() { _state = newState; StateHasChanged(); } 内存泄漏 // 错误方式 private void Subscribe() { _eventAggregator.Subscribe(OnEvent); // 未取消订阅 } // 正确方式 private IDisposable _subscription; private void Subscribe() { _subscription = _eventAggregator.Subscribe(OnEvent); } public void Dispose() { _subscription?.Dispose(); } ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:11:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"总结 Razor组件的生命周期管理是开发高质量Blazor应用的关键。通过本文，我们详细探讨了： 完整的生命周期流程 各阶段的最佳实践 性能优化策略 常见问题解决方案 掌握这些知识，将帮助您开发出更稳定、高效的Blazor应用。 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:12:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"},{"categories":["Web开发"],"content":"参考资源 Blazor官方文档 ASP.NET Core文档 Microsoft Blazor组件生命周期指南 .NET性能最佳实践 ","date":"2024-03-18","objectID":"/posts/razor-component-lifecycle/:13:0","tags":["Blazor","Razor",".NET","组件生命周期","Web开发"],"title":"深入理解Razor组件生命周期：从创建到销毁","uri":"/posts/razor-component-lifecycle/"}]